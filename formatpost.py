# accept arguments from command line

import sys
import os
import json

# remove t1_ or t3_ from id
def format_parent_id(parent_id):
    return parent_id[3:]
 

def format_comments(comment_data, depth):
    markdown_depth = "    " * depth if depth > 0 else ""
    markdown = f'{markdown_depth}### {comment_data["score"]} points by {comment_data["author"]["author_name"]}\n\n'
    
    cleaned_body = comment_data["body"].replace('\n', f'\n{markdown_depth}')
    markdown += f'{markdown_depth}{cleaned_body}\n\n'
    # check if a comment has replies
    my_id = comment_data['id']
    if my_id in reply_comments:
        for reply in reply_comments[my_id]:
            markdown += format_comments(reply, depth + 1)
    return markdown

# get arguments from command line
# expect 2 arguments: subreddit name and submission id
if len(sys.argv) != 3:
    print('Usage: python formatpost.py <subreddit_name> <submission_id>')
    sys.exit(1)

subreddit_name = sys.argv[1]
submission_id = sys.argv[2]

# load config from file
with open('config.json', 'r') as file:
    config = json.load(file)

# load submission data from file
# for AmItheAsshole as the subreddit_name and 9v8evv as the submission_id the file paths are: 
# submission json: /data/AmItheAsshole_top_posts.json 
#   (note: this file is generated by app.py)
#   key value pairs are: submission_id: post_data
# top comments json: /data/AmItheAsshole/9v8evv_top_comments.json

# load submission data from file
with open(f'{config["save_dir"]}/{subreddit_name}_top_posts.json', 'r') as file:
    submission_data = json.load(file)

# load top comments from file
with open(f'{config["save_dir"]}/{subreddit_name}/{submission_id}_top_comments.json', 'r') as file:
    top_comments = json.load(file)

# Goal: format submission data and top comments into a single markdown file

#find submission in top posts
submission = submission_data[submission_id]

# format submission data into markdown
markdown = f'# {submission["title"]}\n\n by {submission["author_name"]} in {submission["subreddit"]}\n\n'
markdown += f'## {submission["score"]} points ({submission["upvote_ratio"]}% upvoted) {submission["num_comments"]} comments\n\n'
markdown += f'{submission["text"]}\n\n'
markdown += f'## Top Comments\n\n'

# format top comments into markdown
# comments have an id and a parent_id, which is the id of the comment they are replying to if they are a reply.
# we want to sort by score, but also keep the comments in order of the conversation
# first we will create a top level comment dict sorted by score (key: comment_id, value: comment_data)

top_level_comments = {}
reply_comments = {}
for comment_id, comment_data in top_comments.items():
    if comment_data['parent_id'] == comment_data['link_id']: # if comment is top level
        top_level_comments[comment_id] = comment_data
    else:
        parent_id = format_parent_id(comment_data['parent_id'])
        if parent_id in reply_comments:
            reply_comments[parent_id].append(comment_data)
        else:
            reply_comments[parent_id] = [comment_data]

# sort top level comments by score
top_level_comments = {k: v for k, v in sorted(top_level_comments.items(), key=lambda item: item[1]['score'], reverse=True)}
# sort each reply list by score
for reply_list in reply_comments.values():
    reply_list.sort(key=lambda item: item['score'], reverse=True)

# now we will iterate through the top level comments and add them to the markdown.
# if a comment has replies, we will add them to the markdown as well.


for comment_id, comment_data in top_level_comments.items():
    markdown += format_comments(comment_data, 0)

    

# save markdown to file
with open(f'{config["save_dir"]}/{subreddit_name}/{submission_id}.md', 'w', encoding="utf-8") as file:
    file.write(markdown)
